# 2.1 들어가며
# 2.2 런타임 데이터 영역
## 2.2.1 프로그램 카운터(어디까지 읽었는지 각 스레드에 기록)
- JVM은 바이트코드 하나씩 읽어서 실행하는데 어디까지 읽었는지 기록하는게 PC 
- 스레드가 context switching될 때 pc에 기록해두고 다음부터 이어나감
	
## 2.2.2 자바 가상 머신 스택 (생애 주기)
- 각 스레드마다 존재하며, 메서드 호출 시마다 스택 프레임을 쌓아 올리는 구조
- 자바 바이트코드를 실행하기 위한 작업 공간
	
## 2.2.3 네이티브 메서드 스택
- 운영체제나 하드웨어와 직접 통신해야 할 때 사용한다.

	public class MyClass {
    public native void callCMethod();  // C로 작성된 메서드
    static {
        System.loadLibrary("MyLibrary");  // 네이티브 라이브러리 로드
    }
	}
	
- 네이티브 스택도 과도하게 사용되면  
→ `StackOverflowError` or `UnsatisfiedLinkError` 발생 가능

## 2.2.4 자바 힙
- 자바 힙은 객체가 저장되는 메모리 영역이며, GC가 이 공간을 관리한다.
  
## 2.2.5 메서드 영역
- 클래스 수준의 정보(코드 자체, static 변수 등)를 저장하는 JVM 메모리 영역
- 모든 스레드가 공유해서 사용
- 클래스 정보 (이름, 부모 클래스, 메서드, 필드 등)
- static 변수
- final 상수 (e.g. static final String A = "abc";)
- 메서드 코드(바이트코드)
- 런타임 상수 풀 (Runtime Constant Pool)
- 인터페이스 정보
- 예전에는 PermGen(영구 영역)이라는 영역이 메서드 영역 역할을 했지만 Java 8부터 Metaspace로 바뀜 (더 유연하게 OS 메모리를 사용)

## 2.2.6 런타임 상수 풀
- 런타임 상수 풀은 클래스에서 사용하는 상수와 참조 정보를 저장하는 메서드 영역 내의 테이블이다.
- "클래스나 인터페이스에서 사용되는 상수와 심볼릭 참조 정보를 저장하는 공간"  
메서드 영역 내부에 존재하고, JVM이 실행 중에 참조하는 '상수 테이블'

## 2.2.7 다이렉트 메모리
- JVM 힙이 아닌, 운영체제가 직접 관리하는 메모리 영역
**왜 사용하는지?**
- 기본적으로 자바는 객체를 힙에 생성하고,  
파일이나 네트워크 I/O를 할 때 힙 → 커널 → 디스크 이렇게 거쳐야 하는데
이 과정에서 복사(copy overhead)가 발생.
**하지만**, 다이렉트 메모리를 사용하면, 힙을 거치지 않고 JVM 바깥의 native memory를 직접 사용해서
I/O 성능을 대폭 향상시킬 수 있음

# 2.3 핫스팟 가상 머신에서 객체 들여다보기
- **핫스팟**
- 핫한 코드를 최적화한다고 해서 핫스팟임
- JVM 구현체 중 하나이고 자주 실행되는 코드를 더 빠르게 실행하기 위해 JIT 컴파일을 사용하는 고성능 JVM이다.

## 2.3.1 객체 생성
- new키워드로 객체 생성하면 힙에 할당하고 생성된 객체는 스택에 있는 변수가 참조한다.
- **JVM이 new 키워드를 만났을 때 과정**
  1. 매개변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다.
  2. 그다음 심벌참조가 뜻하는 클래스가 로딩, 해석, 초기화되었는지 확인한다.
  3. 준비되지 않은 클래스라면 로딩부터하고 로딩을 완료한다.
  4. 로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다.
  5. 할당받은 공간을 0으로 초기화
  6. 각 객체에 필요한 설정을 해줌
  7. 이후 init 메서드까지 실행되어 객체를 개발자의 의도대로 최기화하면 사용하능한 진짜 객체 완성
- **메모리 할당방식**
- 자바힙이 규칙적인지 아닌지, 자바힙이 사용하는 가비지 컬렉터가 컴팩트 할수 있냐에 따라 bump the point 사용하거나 free list를 사용한다. 
- **Race Condition**
- 한 스레드가 요청한 객체 A를 위해 메모리를 할당하는 과정에서, 포인터의 값을 아직 수정하기 전에 다른 스레드가 객체 B용 메모리를 요청할 수 있다.
- **레이스 컨디션의 해결법**
  1.  메모리 할당을 동기화
    - 갱신을 원자적으로 
  2.  tlab 로컬할당버퍼
     - 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당받아 놓는것이다.
 
- 자바 컴파일러는 자바의 new 키워드를 발견하면 바이트코드 명령어인 new와 invokespecial로 변환한다.
- invokespecial: init 메서드의 호출을 담당
## 2.3.2 객체의 메모리 레이아웃
JVM이 객체를 힙에 저장할 때 어떤 구조로 저장하는지를 의미
  1. 객체 헤더
  - 마크워드: 객체 자체의 런타임 데이터 (해시코드, gc 세대나이, 락 상태 플래그, 스레드가 점유하고 있는 락들) 
  - 클래스 워드: 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장
  - 배열 길이
  2. 인스턴스 데이터
    - 객체가 실제로 담고있는 정보 (필드 관련정보, 부모 클래스 유무, 부모클래스에서 정의한 모든 필드가 기록)
  3. 정렬패딩
- 큰 의미 없이 자리를 확보하는 역할
- 시스템에서 객체의 시작주소는 반드시 8바이트의 정수배여야 한다.
## 2.3.3 객체에 접근하기
  힙에 저장된 객체의 필드나 메서드를 참조해서 사용하는 것
  


2.4 실전: OutOfMemory 예외
2.4.1 자바 힙 오버플로
2.4.2 가상 머신 스택과 네이티브 메서드 스택 오버플로
2.4.3 메서드 영역과 런타임 상수 풀 오버플로
2.4.4 네이티브 다이렉트 메모리 오버플로


