# 런타임 데이터 영역
## 프로그램 카운터(PC)
JVM에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행할 수 있다. 따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 PC가 필요하다. 따라서 각 스레드의 PC는 서로 영향을 주지 않는 독립된 영역에 저장되는데 이 영역을 스레드 프라이빗 메모리라고 한다.

스레드가 네이티브 메서드를 실행 중일 때 PC의 값은 Undefined다. 프로그램 카운터 메모리 영역은 `OutOfMemoryError` 조건이 명시되지 않은 유일한 영역이다.
**→ C/C++ 같은 외부 언어로 만든 '네이티브 메서드'를 실행하고 있을 때는 PC가 어떤 명령어를 가리키고 있는지 JVM이 따로 신경쓰지 않는다. 그래서 이 값은 `Undefined` 즉 의미가 없는 상태라는 뜻이다. JVM은 메모리가 부족하면 `OutOfMemoryError`를 던지지만 PC는 아주 작고 단순한 공간이라 메모리가 부족해질 일이 없어서 이러한 에러 상황이 명시조차 되어 있지 않다는 뜻이다.**

## 자바 가상 머신 스택
PC처럼 자바 가상 머신 스택도 'thread private'하며, 연결된 스레드와 생성/삭제 시기가 일치하다. 자바의 메모리 영역을 힙 메모리와 스택 메모리로 구분하는 사람이 많다. 이 구분법은 전통적인 C/C++ 프로그램의 메모리 구조에서 기인한 것으로 자바 언어를 설명하기에는 무리가 있다. 자바의 메모리 영역 구분은 훨씬 복잡하다. '스택'이라고 하면 보통 자바 가상 머신 스택을 가리키는데, 그중 특히 지역 변수 테이블을 가리킬 때가 많다.
지역 변수 테이블에는 자바 가상 머신이 컴파일 타임에 알 수 있는 다양한 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라하고, 일반적으로 슬롯 하나의 크기는 32비트다. 예를 들어 double 타입은 길이가 64비트이므로 슬롯 두 개를 차지하며, 나머지 타입은 모두 슬롯 하나에 저장된다.

지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 자바 메서드는 스택 프레임에서 지역 변수용으로 할당 받아야 할 공간의 크기(변수 슬롯 개수. JVM을 어떻게 구현하느냐에 따라 실제 크기는 달라질 수 있다)가 이미 완벽하게 결정되어 있다. 메서드 실행 중에는 절대 변하지 않는다.
**→ 예를 들어 A메서드를 만들고 거기서 사용할 `int a, int b, String name` 등을 선언했다면 JVM은 컴파일할 때 미리 '3칸이 필요하겠구나!' 계산해서 확보해둔다. 이는 한 번 정해지면 런타임에는 절대 바뀌지 않는다.**

스택 메모리 영역에서는 두 가지 오류가 발생할 수 있다. (1) 스레드가 요청한 스택 깊이가 가상 머신이 허용한 깊이보다 클 때 `StackOverflowError`를 던진다. (2) 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 `OutOfMemoryError`를 던진다.

## 네이티브 메서드 스택
가상 머신 스택과 비슷한 역할을 하지만, 가상 머신 스택은 자바 메서드(바이트코드)를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다. 가상 머신 스택처럼 네이티브 메서드 스택도 스택 허용 깊이를 초과하면 `StackOverflowError`, 스택 확장에 실패하면 `OutOfMemoryError`를 던질 수 있다.

## 자바 힙
자바 애플리케이션이 사용할 수 있는 가장 큰 메모리다. 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다. 이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것이다. 자바 힙은 가비지 컬렉터가 관리하는 메모리 영역이다. 메모리 회수 관점에서 대다수 현대적인 가비지 컬렉터는 세대별 컬렉션 이론(generational collection theory)을 기초로 설계됐다. 그래서 자바 힙을 설명할 때 신세대(new generation), 구세대(old generation), 영구 세대, 에덴 공간(eden space), 생존자 공간에서부터(from survivor space)', 생존자 공간으로부터(to survivor space) 같은 용어가 자주 등장한다. 이러한 개념은 가비지 컬렉터들의 일반적인 특성 또는 설계 방식일 뿐, 반드시 이 형태로 메모리를 구성해야 한다는 뜻은 아니다. 오늘날의 가비지 컬렉터 기술은 세대 단위 설계를 따르지 않는 컬렉터가 포함되어 있기도 하다.

메모리 할당 관점에서 자바 힙은 모든 스레드가 공유한다. 따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러 개로 나뉜다. 어떤 세부 영역이든 객체의 인스턴스만 저장할 수 있는데 자바 힙을 다시 작게 구분하는 목적은 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.
**→ 자바 힙은 모든 스레드가 공유하기 때문에 여러 스레드가 동시에 객체를 만들면 경쟁이 생길 수 있다. 그래서 자바는 속도를 높이기 위해 Thread Local Allocation Buffer(TLAB)라는 걸 만들었다. TLAB는 각 스레드가 자기만 쓸 수 있는 작은 힙 공간으로 객체를 만들 때 작고 자주 쓰는 건 이 버퍼에서 처리하여 빠르게 할당할 수 있다.**

자바 가상 머신 명세에 따르면 자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관없으나 논리적으로는 연속되어야 한다. 하지만 대다수 가상 머신이 큰 객체(주로 배열 객체)는 물리적으로도 연속된 메모리 공간을 사용하도록 구현한다. 저장 효율을 높이고 구현 로직을 단순하게 유지하기 위해서다.

## 메서드 영역
자바 힙처럼 모든 스레드가 공유한다. 이 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는 데 이용된다. 자바 가상 머신 명세에서 메서드 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해 Non-heap이라고 부르기도 한다.

메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라 회수 효과가 상대적으로 매우 적다. 특히 타입은 회수할 수 있는 조건이 상당히 까다롭기까지 하다.
**→ 메서드 영역은 클래스 정보를 저장해두는 공간으로 상수 풀(constant pool, 문자열 리터럴, 숫자 상수 등)과 타입 정보(클래스 이름, 메서드 정보 등)이 들어간다. 사실상 가비지 컬렉션으로 회수할 수 있는게 상수랑 클래스(타입) 정보 뿐이라는 것이다. 메서드 영역에 있는 것들은 한 번 로딩되면 프로그램이 끝날 때까지 대부분 없어지지 않고, 크기도 크지 않기 때문에 가비지 컬렉터가 이 영역에서 뭔가 정리해봤자 큰 효과가 없다. 특히 클래스나 인터페이스 같은 정보는 더 이상 참조되지 않고, 클래스 로더도 같이 GC 대상이 되어야 하고, 다른 클래스와의 연결도 끊겨야 겨우 지울 수 있어 클래스 정보를 GC로 지우기 위해서는 엄청 까다로운 조건을 충족해야 한다.**

### 런타임 상수 풀
상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다. 가상 머신이 클래스를 로드할 때 이 정보를 메서드 영역의 런타임 상수 풀에 저장한다.
런타임 상수 풀의 중요한 특징은 바로 동적이라는 점이다. 상수 풀의 내용 전부가 클래스 파일에 미리 완벽하게 기술되어 있는 게 아니다. 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다. 예를 들면 String 클래스의 `intern()` 메서드
**→ 보통 "상수"라고하면 고정된, 바뀌지 않는 값을 생각하는데 런타임 상수 풀은 프로그램이 실행 중에도 새로운 값이 추가될 수 있는 동적인 공간이다.**
```java
String a = new String("hello");
string b = a.intern();
```
**위 코드에서 `intern()`은 어떤 문자열을 상수 풀에 등록하고 같은 문자열이 있으면 그걸 리턴해주는 메소드다. `intern()` 메소드를 사용하면 JVM은 문자열을 상수 풀에 넣을지 확인하고, 없으면 새로 추가한다. 위와 같은 식으로 실행 도중에 새로운 상수가 런타임 상수 풀에 등록될 수 있다.**

# 핫스팟 가상 머신에서의 객체 들여다보기
## 객체 생성
자바 가상 머신이 new 명령에 해당하는 바이트코드를 만나면 매개변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다. 그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석(resolve), 초기화(initialize)되었는지 확인한다. 준비되지 않았다면 로딩부터 하고, 로딩이 완료되면 새 객체를 담을 메모리를 할당한다. 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다.

자바 힙은 규칙적이지 않기 때문에 사용 중인 메모리와 여유 메모리가 뒤섞여 있다. 가상 머신은 가용 메모리 블록들을 목록으로 따로 관리하며, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당한 후 목록을 갱신한다. 이를 free list(여유 목록)라고 한다.

여러 스레드가 동시에 객체를 생성하려고 할 때(멀티스레딩 환경)에는 여우 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 안전하지 않기 때문에 문제가 생길 수 있다. 예를 들어 스레드 A가 요청한 객체 a를 위해 메모리를 할당하는 중 포인터의 값을 아직 수정하기 전에 스레드 B가 객체 b용 메모리를 요청할 수 있다. 이에 대한 해법은 두 가지다. (1) 메모리 할당을 동기화한다. CAS(Comapare-and-swap)과 실패 시 재시도 방식은 이 방법을 채택했다. (2) 스레드마다 다른 메모리 공간을 할당한다. 위에서 설명한 TLAB가 예다.

메모리 할당이 끝나면 가상 머신은 할당받은 공간을 0에 해당하는 값으로 초기화한다. 예를 들면 int, long 등의 숫자형은 0, boolean은 false, String이나 객체는 null로 초기화한다. 자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유가 바로 이 단계 덕이다. 모든 필드가 자연스럽게 각 데이터 타입에 해당하는 0 값을 담고 있게 되는 것이다.
**→ 자바는 안정성과 예측 가능한 실행을 중요하게 생각한다. C 언어 같은 경우에는 초기화하지 않으면 엉뚱한 값이 들어갈 수 있는데, 자바는 그걸 방지하기 위해 기본값 자동 설정을 해주는 것이다.**

## 객체의 메모리 레이아웃
### 객체 헤더
(1) 마크 워드(mark word): 해시 코드, GC 세대 나이, 락 상태 플래그, 스레드가 점요하고 있는 락들, 편향된 스레드의 아이디, 편향된 시각의 타임스탬프 등을 저장한다. 마크 워드의 데이터 구조는 동적으로 의미가 달라진다. 작은 공간에 가능한 한 많은 정보를 담고 객체 상태에 따라 공간을 재활용할 수 있게 하기 위해서다.

(2) 클래스 워드(klass word): 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장된다. JVM은 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다.

### 인스턴스 데이터
객체가 실제로 담고 있는 정보다. 프로그램 코드에서 정의한 다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 이 부분에 기록된다.

### 정렬 패딩
특별한 의미 없이 자리를 확보하는 역할을 한다. 그래서 이 부분은 존재하지 않을 수도 있다.

## 객체에 접근하기
자바 가상 머신 명세에는 참조 타입을 '객체를 가리키는 참조'라고만 정했을 뿐, 힙에서 객체의 정확한 위치를 알아내어 접근하는 구체적인 방법은 규정하지 않았다. 그래서 객체에 접근하는 방식은 가상 머신에서 구현하기 나름이다. 주로 핸들이나 다이렉트 포인터를 사용해 구현한다.

(1) 핸들 방식: 자바 힙에 핸들 저장용 풀이 별도로 존재한다. 참조에는 객체의 핸들 주소가 저장되고, 핸들에는 다시 해당 객체의 인스턴스 데이터, 타입 데이터, 구조 등의 정확한 주소 정보가 담긴다. 가장 큰 장점은 참조에 '안정적인' 핸들의 주소가 저장된다는 것이다. GC 과정에서 객체가 이동하는 일은 아주 흔한데, 핸들을 이용하면 객체의 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없다. 핸들 내의 인스턴스 데이터 포인터만 변경하면 된다.

(2) 다이렉트 포인터 방식: 자바 힙에 위치한 객체에서 인스턴스 데이터 뿐만 아니라 타입 데이터에 접근하는 길도 제공해야 한다. 스택의 참조에는 객체의 실제 주소가 바로 저장되어 있다. 가장 큰 장점은 '속도'다. 핸들을 경유하는 오버헤드가 없기 때문이다. 자바에서는 다른 객체에 접근할 일이 아주 많기 때문에 이 오버헤드도 실행 시간에 영향을 크게 줄 수 있다.
